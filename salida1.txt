main.cpp

//----------------------------------------
//Importamos las librerias a utlizar
#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <LittleFS.h>
#include <SPI.h>
#include <DNSServer.h>
//---------------------------------------
#include <LedLib.h>
#include <MFRC522.h>
#include <ArduinoJson.h>
#include <ESP8266HTTPClient.h>
#include <ESPAsyncTCP.h>
#include <ESPAsyncWebServer.h>


//-----------------------------------------------
//Incluimos los archivos de cabezera que tenemos
//en la carpeta include
//---------------------------------------
#include "config.hpp"
#include "wifiConfig.hpp"
#include "configHelper.hpp"
//------------------------------------
#include "rfidHelp.hpp"
#include "asyncServer.hpp"
//------------------------------------
//Este objeto es en donde indicaremos en que pines esta conectado nuestro
//Rfid el igual 
MFRC522 rfid(pinCS, pinRS);

//Creamos dos objetos los cuales nos ayudaran a mostrar el estado del Wi-fi
//y si se ha leido una tarjeta rfid
ledLibClass ledRFID;
ledLibClass ledWIFI;

//Objeto en donde indicamos la ruta de nuestro websocket
AsyncWebSocket asyncSocket("/ws");
//Objeto en donde indicamos el puerto por el cual se ejecutara //nuestro servidor
AsyncWebServer asyncServer(80);
DNSServer dnsServer;
bool mostrarIPSTA = true;

//=============================================================
//Inicia los eventos websockets
void iniciarSocket(){
  asyncSocket.onEvent(&onWsEvent);
}

//=============================================================
//Inicia el servidor web al igual que el DNS
void iniciarServerYDNS(){

  dnsServer.setTTL(300);
  dnsServer.setErrorReplyCode(DNSReplyCode::ServerFailure);
  dnsServer.start(DNS_PORT,"www.rfid.com",apIp);
  //--------------------------------------------
  addRouters(asyncServer);
  asyncServer.addHandler(&asyncSocket);
  iniciarSocket();
  asyncServer.begin();
  //----------------------------

}

//=============================================================
//Indica el estado de la conexion WI-Fi atravez de un led
void actualizaEstadoWiFi(){
  if(!WiFi.localIP().isSet()){
    ledWIFI.prenderInfinito(1000,500);
    mostrarIPSTA = true;
  }else{
    ledWIFI.parar();
    ledWIFI.prender();
    if(mostrarIPSTA){
      Serial.printf("Conectado a WIFI %s con ip: %s",WiFi.SSID().c_str(),WiFi.localIP().toString().c_str());
      mostrarIPSTA = false;
    }
  }
}

//=============================================================
//Inicia los objetos leds con lo pines configurados en config.h
void iniciarLeds(){
  ledRFID.begin(pinLed, TipoLed::Catodo);
  ledWIFI.begin(pinLedWIFI,TipoLed::Anodo);
}

//=============================================================
//Inicia el sistema de archivos en nuestro ESP para leer archivos
//y escribir en el
bool iniciarLittleFS(){
  Serial.println();
  Serial.println(F("Lectura de Tarjeta"));
  
  
  Serial.println(F("Montando LittleFS"));
  if (!LittleFS.begin()) {
    Serial.println(F("LittleFS Error al montar"));
    return false;
  }

  return true;
}
//=============================================================
//Metodo auxiliar en donde se iniciaran todos los objetos de la
//con sus respectivas configuraciones de config.h
bool iniciaTodo(){
//-----------LEDS-----------------
  iniciarLeds();
  //----------LITTLEFS------------------
  iniciarLittleFS();
  cargarConfi();
  //-----------WIFI-----------------
  iniciarSTAWiFI();
  conectarWiFi();
  //-----------Servidor-----------------
  iniciarServerYDNS();

  return true;
}


//=============================================================
//Metodo principal en donde inicia nuestra aplicacion
//Este solo se ejecutar una  vez, al principio

void setup()
{
  Serial.begin(9600);
  SPI.begin();
  rfid.PCD_Init();


  iniciaTodo();
  
}

//=============================================================
//Metodo loop el cual se ejecutara infinitamente
void loop()
{

  dnsServer.processNextRequest();
  actualizaEstadoWiFi();
  ledRFID.loop();
  ledWIFI.loop();
  if (tarjetaDisponible(rfid))
  {
    ledRFID.prender(100, 50, 4);
    String strId = leerTarjeta(rfid);
    enviarPostApi(strId);
    Serial.println(strId);

    // Serial.printf("Espacio total %d \n",ESP.getFlashChipSize());
    // Serial.printf("Espacio disponible stack %d \n",ESP.getFreeContStack());
    // Serial.printf("Espacio disponible heap %d \n",ESP.getFreeHeap());
  }


  enviarInfoCada(2000,asyncSocket);
  comprobarClientes(1000,asyncSocket);
}
asyncServer.hpp
// Cliente htpp para realizar solicituedes http al servidor
//Correcion de error
HTTPClient http;
WiFiClient cli;

// Documento json que contendra informacion para solicitudes htpp
StaticJsonDocument<48> json;
String jsonStr;

// Documento json que contendra informacion para ls clientes sockets conectados
StaticJsonDocument<100> jsonWS;
String jsonStrWS;

// Variables auxiliares para controlar cada cierto tiempo se
// limpiaran clietes o se enviara informacion a los clientes
// websockets
ulong_t tiempoInicialSockets = 0;
ulong_t tiempoLimpiaClientes = 0;

//==============================================================
// Metodo para liberar clientes websockets conectados
static void comprobarClientes(long comprobarCada, AsyncWebSocket &socket)
{
   if (tiempoLimpiaClientes == 0)
   {
      tiempoLimpiaClientes = millis();
   }

   if (millis() - tiempoLimpiaClientes > comprobarCada)
   {

      socket.cleanupClients();
      tiempoLimpiaClientes = millis();
   }
}

//=============================================================
// Envia informacio sobre Wi-Fi a clientes websockets conectados
void enviarInfoWS(AsyncWebSocket &socket)
{

   if (socket.count() == 0)
      return;
   JsonObject ob = jsonWS.createNestedObject("WiFi");
   ob["CONECTADO"] = wifiConectado();
   ob["NOMBRE"] = WiFi.SSID();
   ob["RSSI"] = WiFi.RSSI();

   serializeJson(jsonWS, jsonStrWS);
   socket.textAll(jsonStrWS);
   jsonWS.clear();
   jsonStrWS.clear();
   Serial.println(F("Enviando"));
}

//=============================================================
// Envia informacio a clientes websockets cada clerto tiempo
void enviarInfoCada(long espera, AsyncWebSocket &socket)
{
   if (tiempoInicialSockets == 0)
   {
      tiempoInicialSockets = millis();
   }

   if (millis() - tiempoInicialSockets > espera)
   {
      enviarInfoWS(socket);
      tiempoInicialSockets = millis();
   }
}

//=============================================================
// Realiza una peticion POST a nuestra api
// Utiliza la ruta de la Api configurada en archivos de configuracion
void enviarPostApi(String &uuid)
{
   if (WiFi.status() != WL_CONNECTED)
   {
      Serial.println("Wifi no conectado");
      return;
   }
   
   json["uuid"] = uuid;

   serializeJson(json, jsonStr);
   http.begin(cli, (serverIp + rutaApi));
   http.addHeader("Authorization", "Bearer " + String(token));
   http.addHeader("Content-Type", "application/json");
   http.addHeader("Connection", "keep-alive");

   int code = http.POST(jsonStr.c_str());

   if (code == 200)
   {
      Serial.println(F("Peticion realizada con exito"));
   }
   else
   {
      Serial.println(F("Erro al realizar la peticion"));
      Serial.println(http.errorToString(code));
   }

   http.end();
   cli.stop();
   cli.flush();
   json.clear();
   jsonStr.clear();
}

//=============================================================
// Metodo que procesa la informacion que es enviada de un cliente de
// desde websockets
void ProcessRequest(AsyncWebSocketClient *client, String mensaje)
{
}

//=============================================================
// metodo que contiene los eventos de los clientes websockets
void onWsEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len)
{
   if (type == WS_EVT_CONNECT)
   {
      Serial.printf("ws[%s][%u] conectado\n", server->url(), client->id());
      Serial.printf("Clientes conectados [%u]\n", server->getClients().length());
      client->ping();
   }
   else if (type == WS_EVT_DISCONNECT)
   {
      Serial.printf("ws[%s][%u] desconcectadd: %u\n", server->url(), client->id());
   }
   else if (type == WS_EVT_ERROR)
   {
      Serial.printf("ws[%s][%u] error(%u): %s\n", server->url(), client->id(), *((uint16_t *)arg), (char *)data);
   }
   else if (type == WS_EVT_PONG)
   {
      Serial.printf("ws[%s][%u] pong[%u]: %s\n", server->url(), client->id(), len, (len) ? (char *)data : "");
   }
   else if (type == WS_EVT_DATA)
   {
      AwsFrameInfo *info = (AwsFrameInfo *)arg;

      String msg = "";
      if (info->final && info->index == 0 && info->len == len)
      {

         if (info->opcode == AwsFrameType::WS_TEXT)
         {
            for (size_t i = 0; i < info->len; i++)
            {
               msg += (char)data[i];
            }
         }
         else
         {
            char buff[3];
            for (size_t i = 0; i < info->len; i++)
            {
               sprintf(buff, "%02x ", (uint8_t)data[i]);
               msg += buff;
            }
         }
      }
      else
      {
         // message is comprised of multiple frames or the frame is split into multiple packets
         if (info->opcode == WS_TEXT)
         {
            for (size_t i = 0; i < len; i++)
            {
               msg += (char)data[i];
            }
         }
         else
         {
            char buff[3];
            for (size_t i = 0; i < len; i++)
            {
               sprintf(buff, "%02x ", (uint8_t)data[i]);
               msg += buff;
            }
         }
         Serial.printf("%s\n", msg.c_str());
         if ((info->index + len) == info->len)
         {
            if (info->final)
            {
               if (info->message_opcode == WS_TEXT)
                  ProcessRequest(client, msg);
            }
         }
      }
   }
}

//=============================================================
// Indica en que parte de la memoria se encuentran los archivos
// estaticos para el servidor
void filesStatic(AsyncWebServer &async)
{
   async.serveStatic("/www", LittleFS, "/www/");
}
//=============================================================
// Ruta Login de nuestro servidor
// Metodo de acceso GET
void handleLoginGet(AsyncWebServerRequest *req)
{
   if (!LittleFS.exists("/login.html"))
   {
      req->send(404, "text/plain", "No encontrado");
      return;
   }

   req->send(LittleFS, "/login.html", "text/html");
}
//=============================================================
// Ruta Login de nuestro servidor
// Metodo de acceso POST
void handleLoginPost(AsyncWebServerRequest *req)
{

   int numParametros = req->params();

   if (numParametros == 2)
   {
      String pUsuario = req->getParam(0)->value();
      String pContra = req->getParam(1)->value();
      if (strcmp(pUsuario.c_str(), usario) == 0 &&
          strcmp(pContra.c_str(), contra) == 0)
      {
         req->redirect("/home");
      }
      Serial.println((strcmp(pUsuario.c_str(), usario) == 0 &&
                      strcmp(pContra.c_str(), contra) == 0));
   }
   else
   {
      req->redirect("/");
   }
}
//=============================================================
// Ruta principal de nuestro servidor
// Metodo de acceso GET
void handlePrincipalGet(AsyncWebServerRequest *req)
{
   if (!LittleFS.exists("/principal.html"))
   {
      req->send(404, "text/plain", "No encontrado");
      return;
   }

   File f = LittleFS.open("/principal.html", "r");
   String doc = f.readString();
   doc.replace("#nombre#", ssid);
   doc.replace("#contra#", password);
   doc.replace("#servidor#", serverIp);
   doc.replace("#api#", rutaApi);

   req->send(200, "text/html", doc);
}

//=============================================================
// Ruta principal de nuestro servidor
// Metodo de acceso POST
void handlePrincipalPost(AsyncWebServerRequest *req)
{
   int numParametros = req->params();
   // nombre
   //  contra
   //  servidor
   //  api
   if (numParametros == 4)
   {
      String pNombre = req->getParam(0)->value();
      String pContra = req->getParam(1)->value();
      String pServidor = req->getParam(2)->value();
      String pApi = req->getParam(3)->value();

      ssid = pNombre;
      password = pContra;
      serverIp = pServidor;
      rutaApi = pApi;

      guardarConfigjson();
      conectarWiFi();
      req->redirect("/home");
   }
   else
   {
      req->redirect("/home");
   }
}
//=============================================================
// Agrega las rutas a nuestro servidor embebido

//=============================================================
// Envia un json con las conexiones wifi actuales
const String NombreSeguridad [] = {"ABIERTA","WEP","WPA_PSK","WPA2_PSK","WPA_WPA2_PSK","AUTH_MAX"};


void handleApiGetNetworks(AsyncWebServerRequest *req)
{

   int redesDispo = WiFi.scanComplete();

   StaticJsonDocument<600> jsonWifi;
   JsonArray jsonRedes = jsonWifi.createNestedArray("redes");
   
   if (redesDispo == -2)
   {
      jsonWifi["count"] = 0;
      WiFi.scanNetworks(true);
   }
   else if(redesDispo)
   {

      jsonWifi["count"]= redesDispo;
      for (int i = 0; i < redesDispo; ++i)
      {
         JsonObject jsonRed = jsonRedes.createNestedObject();
         jsonRed["ssid"] = WiFi.SSID(i);
         jsonRed["rssi"] = WiFi.RSSI(i);
         jsonRed["enc"] = NombreSeguridad[WiFi.encryptionType(i)];
         jsonRed["channel"] = WiFi.channel(i);
     }
     
      WiFi.scanDelete();

      if(WiFi.scanComplete() == -2){
         WiFi.scanNetworks(true);
      }
   }

   String jsonString;
   serializeJson(jsonWifi, jsonString);

   AsyncWebServerResponse *response = req->beginResponse(200, "application/json", jsonString);
   response->addHeader("Access-Control-Allow-Origin", "*");
   req->send(response);

}

void addRouters(AsyncWebServer &asyncServer)
{
   filesStatic(asyncServer);
   
   asyncServer.on("/", HTTP_GET, handleLoginGet);
   asyncServer.on("/", HTTP_POST, handleLoginPost);
   asyncServer.on("/home", HTTP_GET, handlePrincipalGet);
   asyncServer.on("/home", HTTP_POST, handlePrincipalPost);
   asyncServer.on("/api/redes", HTTP_GET, handleApiGetNetworks);
   asyncServer.onNotFound([](AsyncWebServerRequest *req)
                          { req->send(LittleFS, "/noEncontrado.html", "text/html"); });
}
config.hpp
//=====================================================
//Archivo de configuraciones
//=====================================================

//=====================================================
// WIFI pagina web
String ssid = "TP-Link_8BB6";
String password = "71904382";
String serverIp = "http://192.168.0.104:44355";
String rutaApi = "/api/ident/";
bool modoRegistro = false;


//=====================================================
//Punto de acceso

const char* ssidAP = "RFID_AP";
const char* passwordAP ="RFID2022MA";

//=====================================================
// DNS
const byte DNS_PORT = 53;
//=====================================================
// Punto de acceso
IPAddress apIp(192, 168, 1, 1);

//=====================================================
// Pines
uint8_t pinLed = LED_BUILTIN;
uint8_t pinLedWIFI = D2;
uint8_t pinRS = D0;
uint8_t pinCS = D8;
//=====================================================
//usuerio y contraseña para la login  pagina web embebida
const char *usario = "rfid";
const char *contra = "1234";


//Token para realizar la peticion http a webserver IIS ASP
const char* token = "api123";
configHelper.hpp
//============================================================
//Guarda la confguracion en la memoria del ESP
//En un archivo JSON para leerlo facilmente
void guardarConfigjson(){
    String strJson;
    StaticJsonDocument<1000> json;
    json["ssid"] =  ssid;
    json["password"] = password;
    json["ServerIp"] = serverIp;
    json["rutaApi"] = rutaApi;
    json["modoRegistro"] = modoRegistro;
    serializeJson(json,strJson);

    File f = LittleFS.open("/config.json","w");

    f.print(strJson);
    f.close();
}


//=============================================================
//Lee la configuracion desde la memoria del ESP
//Esta es deserealizada para su facil lectura
void cargarConfi(){
    if(!LittleFS.exists("/config.json")){
        return;
    }
    File configFile = LittleFS.open("/config.json","r");
    StaticJsonDocument<1000> json;
    deserializeJson(json,configFile);
    configFile.close();

    ssid = json["ssid"].as<String>();
    password = json["password"].as<String>();
    serverIp = json["ServerIp"].as<String>();
    rutaApi = json["rutaApi"].as<String>();
    modoRegistro = json["modoRegistro"].as<bool>();
}
rfidHelp.hpp
//=============================================================
//Indica si se encuentra disponible una tarjeta cerca del sensor
bool tarjetaDisponible(MFRC522& rfid)
{
  if (rfid.PICC_IsNewCardPresent())
  {
    if (rfid.PICC_ReadCardSerial())
    {
      return true;
    }
  }
  return false;
}

//=============================================================
//Lee el UUID de la tarjeta que se encuentra en el sensor
String leerTarjeta(MFRC522& rfid)
{
  String strId = "";
  for (int i = 0; i < rfid.uid.size; i++)
  {
    if(i !=0 ){
      strId += ( rfid.uid.uidByte[i] < 0x10 ? "0" : " " );
    }else if(i == 0 and rfid.uid.uidByte[i] < 0x10){
      strId += "0";
    }
    strId += String(rfid.uid.uidByte[i], HEX);
  }
  rfid.PICC_HaltA();
  return strId;
}
wifiConfig.hpp

//=============================================================
//Inicia una nueva conexion a una red Wi-Fi
//Esto con el nombre y contraeña puestos en config.h
void conectarWiFi(){
  if(WiFi.status() == wl_status_t::WL_CONNECTED){
    WiFi.disconnect();
    WiFi.localIP().clear();
  }
  WiFi.begin(ssid,password);
}



//=============================================================
//inicia el puento de acceso del ESP
//Con el nombre y contraseña puestos en config.h
void iniciarSTAWiFI(){
  WiFi.mode(WiFiMode::WIFI_AP_STA);
  WiFi.softAPConfig(apIp,apIp,IPAddress(255,255,255,0));
  WiFi.setAutoReconnect(true);
  //=======================================================
  Serial.println(F("Iniciado Punto de acceso"));
  while(!WiFi.softAP(ssidAP,passwordAP)){
      Serial.print(F("."));
      delay(100);
  }

  Serial.println(F("Punto de acceso iniciado"));
  Serial.println(WiFi.softAPSSID());
  Serial.println(WiFi.softAPIP());
}



//=============================================================
//Indica si el ESP se encuentra concectado a una red WI-FI
bool wifiConectado(){
  return WiFi.localIP().isSet();
}
